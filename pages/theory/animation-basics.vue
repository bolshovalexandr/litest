<template lang="pug">
	LitestWarpper
		.global-article
			h1 Основы анимации

			h2 Общие основы анимации
			h3 12 принципов анимации в WEB
			p Из "12 принципов анимации" в CSS/SMIL-анимации активно используются
			ul
				li Сжатие и растяжение (Squash and stretch) - иллюзия эластичности, веса, скорости и прочих физических свойств объекта
				li Подготовка или упреждение (Anticipation) -  небольшой разгон/отступ в противоположную сторону перед началом движения
				li Доводка и захлест (overlapping) - эффект инерции. Физический объект не может начать двигаться/остановиться моментально. Скорость достигает максимума к середине. Если движение останавливается резко, то нужно создать эффект гашения кинетической энергии
				Codepen(id="qBjOVmq")
				li Смягчение начала и окончания движения, тайминг, движение по дуге - плавные разгон и торможение, инерция, скорость и отсутствие идеально прямых тректорий, частота кадров в начале и конце анимации выше, чем в середине (напр., временные функции ease-* в CSS)
				li Компоновки и фазированные движения: компоновки (отрисовка ключевых кадров и добавление переходов между ними - keyframes и transition в CSS) и фазованные движения (последовательная отрисовка кадров от начала до конца - смена кадров в CANVAS)

			h3 Микровзаимодействия
			ul
				li сайт можно рассматривать как набор статичных состояний, анимацию - как средство их, состояний, объединения (состояния плавно переходят одно в другое, делая сайт бесшовным и помогая пользователю понять, какие новые элементы интерфейса появились и откуда, а куда ушли старые)
				li микровзаимодействие - элемент взаимодействия пользователя с интерфейсом (клики, ховеры, ввод, валидация, ожидание загрузки и т.д.)
				li цель анимации в микровзаимодействиях - сгладить переход при смене состояний интерфейса и управлять вниманием пользователя. Элемент интерфейса должен восприниматься как единое целое

			h2 CSS-анимация
			h3 Анимация переходов между двумя состояниями (transition)
			ul
				li оптимальная длительность большинства анимаций от 0.35s до 1.5s, при этом на основную часть анимации должно приходиться максимум 0.5s, остальное - доводка
					= ' '
					a(href="https://uxdesign.cc/the-ultimate-guide-to-proper-use-of-animation-in-ux-10bd98614fa9") (полезный гайд по длительности анимации)
				li время анимации исчезновения элемента должно быть несколько меньше времени появления
				li основное отличие transition от animation - управление переходом только между двумя состояниями: начальным и конечным
				li можно задавать пошаговый переход при помощи
					code(v-highlight class="css")
						pre.
							transition-timing-function: steps(5, start/end);
				li можно задавать несколько трансформаций одновременно, причем порядок влияет на результат
					code(v-highlight class="css")
						pre.
							transform:
								translate(15px, 15px)
								rotate(90deg);

			h3 Кривая Безье
			ul
				li используется для описания временных функций,
				li кривая - кубическая, по 4-м опорным точкам, где:
				ul
					li т.1 - зафиксирована в координатах (0; 0)
					li т.4 - зафиксирована в координатах (1; 1)
					li т.2 и т.3 мы можем задать в формате
						= ' '
						strong cubic-bezier(x2, y2, x3, y3)
				li по оси X - шкала времени, по Y - шкала прогресса, при этом координаты
				ul
					li по оси X могут принимать значения от 0 до 1
					li по оси Y могут выходить за эти пределы (в т.ч. быть отрицательными)
				li смягчение начала и/или конца движения реализую встроенные функции ease / ease-in / ease-out / ease-in-out
				li Нагляный пример кривой Безье на&nbsp;
					a(href="https://cubic-bezier.com") cubic-bezier.com
				li Примеры ease-функций, включая их математические формулы, на&nbsp;
					a(href="https://easings.net/ru") easings.net

			h3 Анимация с ключевыми кадрами (animation/keyframes)
			ul
				li Если не задан начальный ключевой кадр, то анимация будет проигрываться из исходного стилевого состояния элемента к ближайшему ключевому кадру
				li Если не задан конечный ключевой кадр, то анимация после последнего ключевого кадра проиграется обратно к начальному состоянию
				li animation-fill-mode: forwards зафиксирует стили после исполнения анимации, backwards установит элементу стили первого ключевого кадра до начала анимации, при этом если установлена задержка начала, то стили всё равно будут применены сразу же
				li возможна групировка ключевых кадров: в примере анимируемый элемент сначала изменит свою ширину до 100px и останется в этом состоянии половину времени анимации, за вторую половину времени он растянется от 100px до 200px
					code(v-highlight class="css")
						pre.
							@keyframes stretching {
								0%,
								50% { width: 100px;}
								100% { width: 200px;}
							}

			h3 Производительность анимации
			ul
				li Профилирование и отладка анимации
					ul
						li профилирование анимации выполняется через Perfomance - Record, далее можно поставить запись, и посмотреть, например, что GPU хадействуется при использовании translate3d, однако не используется при transition left
						li отладчик анимации можно включить через Console Drawer (подменю во вкладке console, или нажать Esc при открытой консоли)
						li там же можно выбрать вкладку Rendering (где полезно включить FPS Rendering Stats и Paint Flashing)
				li Рендеринг (заполнение пикселами страницы) разбит на 5 областей, которые выполняются последовательно
					ul
						li 1. JS - внесение изменений в DOM
						li 2. Style - добавление новых CSS-блоков
						li 3. Layout (расстановка) - изменение позиций, размеров и отступов
						li 4. Paint (внешний вид) - цвета, фоны
						li 5. Composite (компоновка) - наложение слоев, прозрачность, трансформация
						li таким образом, например, сдвинув элемент с помощью left мы запустим этапы с 3-го по 5-й, а использовав трансформацию - только 5-й этап
						li на сайте csstriggers можно проверить,
							= ' '
							a(href="https://csstriggers.com/") какие области задействуются при изменении CSS-свойства
						li ограничить область изменений в рамках контейнера можно с помощью свойства contain (это может быть в первую очередь полезно, чтобы сторонние виджеты не вызывали перерендер всего DOM-дерева)
				li Использование GPU
					ul
						li "хак с 3d" - использование анимаций типа translate3d(X, Y, 0), работает только свойствах из области Composite
						li использование will-change: имя_свойства - это дает команду браузеру зарезервировать ресурсы под анимацию
						li will-change следует использовать только на циклических и тяжелых анимациях
						li will-change следует назначать заранее (в обычных стилях для hover, или в hover для active), чтобы браузер успел выделить ресурсы

			h2 SVG-анимация

			h3 Основы SVG
			ul
				li SVG (Scalable Vector Graphics) - язык описания двухмерной графики на базе XML
				li для базовый фигур внутри SVG есть готовые теги (rect, circle, ellipse, line, polygon, polylineи группа элементов - g)
				li polyline - тот же многоугольник (polygon), но без автозамыкания
				li пикселы в SVG - единицы размера по умолчанию, можно использовать проценты (важно: проценты считаются от размеров элемента svg, а не от обертки)
				li координаты задаются атрибутами x и y от левого верхнего угла
				li скругления углов задаются атрибутами rx и ry
				li по отдельности можно управлять прозрачностью фони и обводки, скруглениями концов линий (linecap) и изгибов (linejoin)
				li пунктирная линия
					ul
						li задается свойством stroke-dasharray (пары длина-пробел),
						li пар может быть множество и линия будет со сложным ритмом (stroke-dasharray="4 10 8 16")
						li важно: на изогнутых объектах пробелы могут быть неравномерными в зависимости от толщины обводки
						li обводке можно задать сдвиг свойством stroke-dashoffset

			h3 Отрисовка и размеры SVG
			ul
				li svg отрисовывается на бесконечном холсте, видимая часть (вьюпорт) соответствует размерам svg-элемента (300 * 150 по умолчанию)
				li изменение размеров SVG-элемента не приведет к увеличению содержимого (ибо бесконечный холст)
				li указания масштабируемой области используется атрибут viewBox="x y width height"
				li после указания viewBox изображение будет смасштабировано, чтобы уместиться в контейнер, и выровнено по центру по умолчанию
				li preserveAspectRatio отвечает за сохранение пропорций, выравнивание и заполнение
				li preserveAspectRatio не работает без viewBox и не работает, если отношение сторон вьюбокса и вьюпорта совпадают (тогда происхдит масштабирование 1 в 1)
				li svg в фоне ведет себя также, т.о. для резиновых фонов достаточно указать viewBox не задавая самому svg размеров (для абстрактных фонов можно попробовать preserveAspectRatio="none")
				li В SVG есть два системы координат: viewport space (коорд. вьюпорта) и user space (коорд. содержимого), если вьюбокс перестанет совпадать с вьюпортом, то точка отсчета в сист.коорд. также изменится
				li простым способом анимации прорисовки контура является первоначальная установка смещения, равная длине контура и уменьшение её до нуля (реальную длину контура можно взять js-методом getTotalLength)

			h3 Анимация SVG
			ul
				li для анимации используется тег animate
				li тег animate можно или положить внутрь svg-тега (напр., внутрь rect) или, если надо сгруппировать все анимации, связать по xlink: href (связь чисто по id не работает в Safari)
				li тег animate использует
					ul
						li attributeName - для указания анимируемого атрибута
						li attributeType - тип атрибута (CSS | XML | auto)
						li за анимирование отвечают from + to, или by, from + by, или values (приоритет выше у values, потом from/to и by)
						li конечное состояние: fill: remove | freeze
						li количество повторений: repeatCount (NUMBER | 'indefinite') и repeatDur (останавливает анимацию через заданное время, в т.ч. и в процессе выполнения)
						li перезапуск: restart (always; whenNotActive - разрешает перезапуск только если анимация не выполняется; never - запрещает перезапуск )
						li длительность: dur
						li условие начала: begin
							ul
								li можно задать время, в т.ч. и отрицательное, напр. begin="-2s" dur="4s" запустит анимацию с середины
								li действие: #elementId_dot_event (напр., square.click при котором анимация запустится по клику на svg-тэг с id="square")
								li событие анимации: elementId.begin|end|repeat (repeat - это событие повтора, после которого запустится анимация, причем это событие не может быть последним)
								li события можно комбинировать с задержкой, напр. #ID.begin + 2s
						li условие конца анимации end - один из способов (наряду с repeatDur) прервать анимацию, например указав одному элементу end="action.begin", а элементу с id="action" атрибут begin="click" (напр., таким способом можно прервать анимацию по умолчанию)
					li тег set позовляет без анимации изменить значение атрибута на заданное время
					li тег animateTransform
						ul
							li позовляет применять к элементу аналоги css-трансформаций (attributeName="transform" type="translate|scale|rotate|etc"),
							li с помощью атрибута additive дает возможнность делать накопительные (sum - когда анимация связывается с предыдущей) и относительные анимации (replace - трансформация переопределяет все предыдущие)
							li при одновременном использовании с CSS-трансформациями они будут переопределять друг друга
					li тег animateMotion - анимирование движения объекта вдоль траектории

			h3 Временные функции анимации SVG
			ul
				li keyTimes определяет долю от общего времени анимации, за которую будет выполнен переход между ключевыми кадрами, указанными в values
				li calcMode управляет временной функцией (значение spline задает ручной режим)
				li отличия calcMode="linear|paced" - путь есть точки values="100; 200; 150", тогда для linear будет постоянным время между точками, а для paced - скорость
				li если calcMode установлен в spline, то атрибутом keySplines можно задать точки для кривой Безье
				li важный момент: у keyTimes и keySplines есть ряд тонкостей, связанных с синтаксисом для разных браузеров

			h3 Морфинг контура SVG
			ul
				li морфинг - плавное изменение формы фигуры, который можно реализовать исключительно SMIL-анимацией атрибут d(draw) у тега path, при этом в values указывается список значений, через которые пройдет элемент
				li для каждого состояния количество точек должно быть одинаковым
				li для автоматического приведения количества точек можно использовать shapeshifter.design

			h2 JS-анимация
			h3 FPS и requestAnimationFrame
			h3 Canvas
			ul
				li canvas — это элемент HTML5, который предназначен для создания растрового изображения с помощью JavaScript (т.к. HTML, даже с учетом трансформаций и переходов, не предназначен для анимаций)
				li canvas по умолчанию прозрачен, размером 300 на 150
				li доступ к canvas - метод getContext(2d | webgl | webgl2)
				li canvas поддерживает только один примитив - прямоугольник, прочие фигуры создаются контурами (paths)
				li углы в canvas задаются в радианах (radians = (Math.PI/180)*degrees)
				li canvas позволяет добавить текст, настроить шрифт с помощью метода font и измерить размер текста до вставки методом measureText
				li canvas позволяет вставить изображение по ссылке (метод drawImage, однако важно дождать загрузки изображения по обработчику load)
				li метод clearRect очищает холст, по факту заливая его черным цветом с полной прозрачностью (можно почистить холст, изменив его размеры canvas.width = canvas.width)
				li вращение вокруг своей оси (ctx.rotate) выполняется за счет предварительного смещения холста, при это перед смещением надо сохранить, а после - восстановить состояние (ctx.save() / ctx.restore())
				Codepen(id="wvrNKaO")

			h3 Типовой каркас canvas-анимации
			h4 алгоритм
			ul
				li получаем холст и устанавливаем размеры
				li получаем изображение (запустим анимацию по событию onload) / создаем объект
				li определяем путь и время его прохождения
			p Основные функции
			ul
				li

			h3 Продвинутый каркас canvas-анимации (классы, пересчет координат, perfomance.now)

</template>

<script lang="ts">
import Vue from 'vue';
import Component from 'vue-class-component';
import LitestWarpper from '~/components/litest/wrapper.vue';
import Codepen from '~/components/litest/components/codepen.vue';

@Component({ components: { LitestWarpper, Codepen	} })
export default class Animation extends Vue {
		script!:HTMLScriptElement;

		mounted() {
			this.script = document.createElement('script');
			this.script.type = 'text/javascript';
			this.script.src = 'https://cpwebassets.codepen.io/assets/embed/ei.js';
			document.body.appendChild(this.script);
		}

		beforeDestroy() {
			this.script.remove();
		}
}
</script>

<style lang="scss" scoped>
@import "../../assets/style/globals-litest.scss";
</style>
